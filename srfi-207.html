<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 207: String-notated bytevectors</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>207: String-notated bytevectors</h1>

<p>by
  Daphne Preston-Kendal (external notation),
  John Cowan (procedure design),
  Wolfgang Corcoran-Mathe (implementation)
</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+207+at+srfi+dotschemers+dot+org">srfi-207@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-207">archive</a>.</p>
<ul>
  <li>Received: 2020-08-15</li>
  <li>60-day deadline: 2020-10-14</li>
  <li>Draft #1 published: 2020-08-15</li>
  <li>Draft #2 published: 2020-08-17</li>
  <li>Draft #3 published: 2020-09-09</li>
</ul>

<h2 id="abstract">Abstract</h2>

<p>To ease the human reading and writing of Scheme code involving strings encoded as bytevectors in ASCII-related encodings, a notation for bytevectors is proposed which allows printable ASCII characters to be used literally without being converted to their corresponding integer forms. In addition, this SRFI provides a set of procedures for manipulating bytevectors as if they were strings as far as possible.

<h2 id="issues">Issues</h2>

<p>I notice R6RS actually uses <code>#vu8</code> for its built-in bytevectors where everyone else uses <code>#u8</code>. Should that be supported with a string notation too?

<h2 id="rationale">Rationale</h2>

<p>When bytevectors contain string data in an ASCII-related character encoding (e.g. UTF-8 or ISO 8859), it is much more tractable for human programmers to deal with them in the form <code>#u8"recursion"</code> than in the form <code>#u8(114 101 99 117 114 115 105 111 110)</code>; this is true for strings in many languages which use the Latin script, even when small numbers of non-ASCII characters are used (<code>#u8"r\xE9;cursivit\xE9;"</code>).

<p>In addition, this SRFI provides bytevectors with additional procedures that closely resemble those provided for strings. For example, bytevectors can be padded or trimmed, compared case-sensitively or case-insensitively, searched, joined, and split.

<p>In this specification it is assumed that bytevectors are as defined in R7RS-small 6.9. Implementations may also consider them equivalent to R6RS bytevectors (R6RS 4.3.4) or SRFI 4 <code>u8vector</code>s, depending which kind of homogeneous vectors of unsigned 8-bit integers an implementation supports.

<h2 id="specification">Specification</h2>

<p>To avoid confusion with the names used in other SRFIs, the names of these procedures use the word <dfn>bytestring</dfn> instead of <dfn>bytevector</dfn>. However, these names refer to exactly the same type.

<h3>External notation</h3>

<p>The basic form of a string-notated bytevector is:

<blockquote><code>#u8"</code> <var>content</var> <code>"</code></blockquote>

<p>To avoid character encoding issues within string-notated bytevectors, only printable ASCII characters (that is, Unicode codepoints in the range from U+0020 to U+007E inclusive) are allowed to be used within the <var>content</var> of a string-notated bytevector. All other characters must be expressed through mnemonic or inline hex escapes, and <code>"</code> and <code>\</code> must also be escaped as in normal Scheme strings.

<p>Within the <var>content</var> of a string-notated bytevector:

<ul>
  <li>the sequence <code>\"</code> represents the integer 34;
  <li>the sequence <code>\\</code> represents the integer 92;
  <li>the following mnemonic sequences represent the corresponding integers:
    <table>
      <tr><th>Seq.            <th>Integer
      <tr><td><code>\a</code> <td>7
      <tr><td><code>\b</code> <td>8
      <tr><td><code>\t</code> <td>9
      <tr><td><code>\n</code> <td>10
      <tr><td><code>\r</code> <td>13
    </table>
  <li>the sequence <code>\x</code> followed by one or two hexadecimal digits followed by <code>;</code> represents the integer specified;
  <li>the sequence <code>\</code> followed by zero or more intraline whitespace characters, followed by a newline, followed by zero or more further intraline whitespace characters, is ignored and corresponds to no entry in the resulting bytevector;
  <li>any other printable ASCII character represents the character number of that character in the ASCII/Unicode code chart; and
  <li>it is an error to use any other character or sequence beginning with <code>\</code> within a string-notated bytevector.
</ul>

<p>When the Scheme reader encounters a string-notated bytevector, it produces a datum as if that bytevector had been written out in full. That is, <code>#u8"A"</code> is exactly equivalent to <code>#u8(65)</code>.

<p>A Scheme implementation which supports string-notated bytevectors may not by default use this notation when any of the <code>write</code> family of procedures is called upon a bytevector or upon another datum containing a bytevector. A future SRFI is expected to add a configurable version of the <code>write</code> procedure which may enable the use of this notation in this context.

<h3>Formal syntax</h3>

<p>The formal syntax of Scheme (defined in R7RS-small 7.1) is amended as follows.

<ul>
<li><p>In the definition of ⟨token⟩, after ‘| ⟨string⟩’, insert ‘| ⟨string-notated bytevector⟩’.
<li><p>After the definition of ⟨byte⟩ is inserted:
   <blockquote>
    <p>⟨string-notated bytevector⟩ &rarr; <code>#u8"</code> ⟨string-notated bytevector element⟩* <code>"</code><br>
    ⟨string-notated bytevector element⟩ &rarr; ⟨any printable ASCII character other than <code>"</code> or <code>\</code>⟩<br>
    <span style="margin-left:1em">| ⟨mnemonic escape⟩ | <code>\"</code> | <code>\\</code></span><br>
    <span style="margin-left:1em">| <code>\</code>⟨intraline whitespace⟩*⟨line ending⟩⟨intraline whitespace⟩*</span><br>
    <span style="margin-left:1em">| ⟨inline hex escape⟩</span>
   </blockquote>
</ul>

<h3>Constructor</h3>

<p><code>(bytestring</code>&nbsp;<var>arg</var> …<code>)</code></p>
<p>Convert <var>args</var> into a sequence of small integers and returns them as a bytevector as follows:</p>
<ul>
  <li>
	<p>If <var>arg</var> is an exact integer in the range 0-255 inclusive, it is added to the result.</p>
  </li>
  <li>
	<p>If <var>arg</var> is an ASCII character (that is, its codepoint is in the range 0-127 inclusive), it is converted to its codepoint and added to the result.</p>
  </li>
  <li>
	<p>If <var>arg</var> is a bytevector, its elements are added to the result.</p>
  </li>
  <li>
	<p>If <var>arg</var> is a string of ASCII characters, it is converted to a sequence of codepoints which are added to the result.</p>
  </li>
</ul>
<p>Otherwise, an error satisfying <code>bytestring-error?</code> is signaled.</p>

<h3>Conversion</h3>

<p><code>(bytestring-&gt;hex-string</code>&nbsp;<var>bytestring</var><code>)</code><br>
<code>(hex-string-&gt;bytestring</code>&nbsp;<var>string</var><code>)</code></p>
<p>Convert between a bytevector and a string containing pairs of hexadecimal digits.
If <var>string</var> is not pairs of hexadecimal digits, an error satisfying <code>bytestring-error?</code> is raised.</p>

<p><code>(bytestring-&gt;base64</code>&nbsp;<var>bytevector</var> [<var>digits</var>]<code>)</code><br>
<code>(base64-&gt;bytestring</code>&nbsp;<var>string</var> [<var>digits</var>]<code>)</code></p>
<p>Convert between a bytevector and its base-64 encoding as a string. The 64 digits are represented by the characters 0-9, A-Z, a-z, and the symbols + and /. However, there are different variants of base-64 encoding which use different representations of the 62nd and 63rd digit. If the optional argument <var>digits</var> (a two-character string) is provided, those two characters will be used as the 62nd and 63rd digit instead.
Details can be found in
<a href="https://tools.ietf.org/html/rfc4648">RFC 4648</a>.
If <var>string</var> is not in base-64 format, an error satisfying <code>bytestring-error?</code> is raised.
However, characters that satisfy <code>char-whitespace?</code>
are silently ignored.

<p><code>(list-&gt;bytestring</code>&nbsp;<var>list</var><code>)</code></p>
<p>Convert a list into a bytevector. If the elements of the list are not suitable arguments for <code>bytestring</code>, an error satisfying <code>bytestring-error?</code> is signaled.</p>

<p><code>(list-&gt;bytestring!</code>&nbsp;<var>bytevector at list</var><code>)</code></p>
<p>Generate a sequence of bytes from <var>list</var> and write them into <var>bytevector</var> starting at index <var>at</var>. If the elements of the list are not suitable arguments for <code>bytestring</code>, an error satisfying <code>bytestring-error?</code> is signaled.</p>

<p><code>(bytestring-&gt;list</code>&nbsp;<var>bytevector</var> [ <var>start</var> [ <var>end</var> ] ]<code>)</code></p>
<p>Convert all or part of a bytevector into a list containing suitable arguments for <code>bytestring</code>. If <code>list-&gt;bytestring</code> is applied to the list, the resulting bytevector will be byte for byte the same as <var>bytevector</var>, but the exact contents of the list are not specified by this SRFI.</p>

<h3>Selection</h3>

<p><code>(bytestring-pad</code>&nbsp;<var>bytevector len char-or-u8</var><code>)</code><br>
<code>(bytestring-pad-right</code>&nbsp;<var>bytevector len char-or-u8</var><code>)</code></p>
<p>Returns a bytevector with the contents of <var>bytevector</var> plus sufficient additional bytes at the beginning/end containing <var>char-or-u8</var> (which can be either an ASCII character or an exact integer in the range 0-255) such that the length of the result is at least <var>len</var>.</p>

<p><code>(bytestring-trim</code>&nbsp;<var>bytevector pred</var><code>)</code><br>
<code>(bytestring-trim-right</code>&nbsp;<var>bytevector pred</var><code>)</code><br>
<code>(bytestring-trim-both</code>&nbsp;<var>bytevector pred</var><code>)</code></p>
<p>Returns a bytevector with the contents of <var>bytevector</var>, except that consecutive bytes at the beginning / the end / both the beginning and the end that satisfy <var>pred</var> are not included.</p>

<h3>Replacement</h3>

<p><code>(bytestring-replace</code>&nbsp;<var>bytevector1 bytevector2 start1 end1 [start2 end2]</var><code>)</code></p>
<p>Returns a bytevector with the contents of <var>bytevector1</var>, except that the bytes indexed by <var>start1</var> and <var>end1</var> are not included but are replaced by the bytes of <var>bytevector2</var> indexed by <var>start</var> and <var>end</var>.</p>

<h3>Comparison</h3>

<p><code>(bytestring=?</code> <var>bytevector1 bytevector2</var><code>)</code></p>
<p>Returns <code>#t</code> if <var>bytevector1</var> and <var>bytevector2</var> are the same length and contain the same bytes in the same order; returns <code>#f</code> otherwise.</p>

<p><code>bytestring&lt;?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring&gt;?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring&lt;=?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring&gt;=?</code> <var>bytevector1 bytevector2</var><code>)</code></p>
<p>Returns <code>#t</code> if <var>bytevector1</var> is less than / greater than / less than or equal to / greater than or equal to <var>bytevector2</var>. Comparisons are lexicographical: shorter bytevectors compare before longer ones, all elements being equal.</p>

<p><code>bytestring-ci=?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring-ci&lt;?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring-ci&gt;?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring-ci&lt;=?</code> <var>bytevector1 bytevector2</var><code>)</code><br>
<code>bytestring-ci&gt;=?</code> <var>bytevector1 bytevector2</var><code>)</code></p>
<p>The same as the corresponding procedures without <code>-ci</code>, except that the comparison is done as if any elements in either <var>bytevector</var> that are in the range 65-90 have had 32 added to them.</p>

<h3>Searching</h3>

<p><code>(bytestring-index</code>&nbsp;<var>bytevector pred</var> [<var>start</var> [<var>end</var>]]<code>)</code><br>
<code>(bytestring-index-right</code>&nbsp;<var>bytevector pred</var> [<var>start</var> [<var>end</var>]]<code>)</code></p>
<p>Search <var>bytevector</var> from <var>start</var> to <var>end</var> / from <var>end</var> to <var>start</var> for the first byte that satisfies <var>pred</var>, and return the index into <var>bytevector</var> containing that byte. In either direction, <var>start</var> is inclusive and <var>end</var> is exclusive. If there are no such bytes, returns <code>#f</code>.</p>

<p><code>(bytestring-break</code>&nbsp;<var>bytevector pred</var><code>)</code><br>
<code>(bytestring-span</code>&nbsp;<var>bytevector pred</var><code>)</code></p>
<p>Return two values, a bytevector containing the maximal sequence of characters (searching from the beginning to the end that do not satisfy / do satisfy <var>pred</var>, and another bytevector containing the remaining characters.</p>

<h3 id="joining-and-splitting">Joining and splitting</h3>

<p><code>(bytestring-join</code>&nbsp;<var>bytevector-list delimiter</var> [<var>grammar</var>]<code>)</code></p>
<p>Pastes the bytevectors in <var>bytevector-list</var> together using the <var>delimiter</var> bytevector. The <var>grammar</var> argument is a symbol that determines how the delimiter is used, and defaults to <code>infix</code>. It is an error for grammar to be any symbol other than these four:</p>
<ul>
  <li><code>infix</code> means an infix or separator grammar: insert the delimiter between list elements. An empty list will produce an empty bytevector.</li>
  <li><code>strict-infix</code> means the same as <code>infix</code> if the list is non-empty, but will signal an error satisfying <code>bytestring-error?</code> if given an empty list.</li>
  <li><code>suffix</code> means a suffix or terminator grammar: insert the delimiter after every list element.</li>
  <li><code>prefix</code> means a prefix grammar: insert the delimiter before every list element.</li>
</ul>

<p><code>(bytestring-split</code>&nbsp;<var>bytevector delimiter</var> [<var>grammar</var>]<code>)</code></p>
<p>Divides the elements of <var>bytevector</var> and returns a list of bytevectors using the <var>delimiter</var> (an ASCII character or exact integer in the range 0-255 inclusive). Delimiter bytes are not included in the result bytevectors.</p>
<p>The <var>grammar</var> argument is used to control how <var>bytevector</var> is divided. It has the same default and meaning as in <code>bytestring-join</code>, except that <code>infix</code> and <code>strict-infix</code> mean the same thing. That is, if <var>grammar</var> is <code>prefix</code> or <code>suffix</code>, then ignore any delimiter in the first or last position of <var>bytevector</var> respectively.</p>

<h3>I/O</h3>

<code>(read-textual-bytestring</code>&nbsp; [ <var>port</var> ]<code>)</code>
<p>Read a string in the external format described in this SRFI
from <var>port</var> and return it as a bytevector.
If <var>port</var> is omitted, it defaults to the value of <code>(current-input-port)</code>.
If the characters read are not in the external format,
an error satisfying <code>bytestring-error?</code> is raised.</p>

<p><code>(write-textual-bytestring</code>&nbsp;<var>bytestring</var> [ <var>port</var> ]<code>)</code></p>
<p>Write <var>bytestring</var> in the external format described in this SRFI to <var>port</var>.
If <var>port</var> is omitted, it defaults to the value of <code>(current-output-port)</code>.</p>

<p><code>(write-binary-bytestring</code>&nbsp;<var>port arg</var> …<code>)</code></p>
<p>Outputs each <var>arg</var> to the binary output port <var>port</var> using the same interpretations as <code>bytestring</code>, but does not create any bytevectors.</p>

<h3>Exception</h3>

<p><code>(bytestring-error?</code>&nbsp;<var>obj</var><code>)</code></p>
<p>Returns <code>#t</code> if <var>obj</var> is an object signaled by any of the
following procedures, in the circumstances described above:</p>
<ul>
  <li><code>bytestring</code></li>
  <li><code>hex-string-&gt;bytestring</code></li>
  <li><code>base64-&gt;bytestring</code></li>
  <li><code>list-&gt;bytestring</code></li>
  <li><code>bytestring-join</code></li>
  <li><code>read-textual-bytestring</code></li>
  <li><code>write-binary-bytestring</code></li>
</ul>

<h2 id="implementation">Implementation</h2>

<p>The procedures specified in this SRFI, but not the notation, are to be provided with a sample implementation.

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Daphne Preston-Kendal devised the string notation for bytevectors; John Cowan, the procedure library; Wolfgang Corcoran-Mathe, the sample implementation of the procedures.

<p>The notation is inspired by the notation used in Python since version 2.6 for <code>bytes</code> objects, which are fundamentally similar in purpose to Scheme bytevectors, especially in R7RS. In addition, many of the procedures are closely analogous to those of <a href="http://srfi-152/srfi-152.html">SRFI 152</a>.

<p>Thanks is also due to the participants in the SRFI mailing list. In particular: Lassi Kortela corrected an embarrassing technical error; Marc Nieper-Wißkirchen explained why the <code>write</code> procedure ought not to be allowed to use this notation by default.

<h2 id="copyright">Copyright</h2>
<p>© 2020 Daphne Preston-Kendal, John Cowan, and Wolfgang Corcoran-Mathe.</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
